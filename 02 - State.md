# 2. Состояние (State)

**Состояние -- это последовательность значений, растянутая во времени**, которая содержит промежуточные результаты желаемого вычисления.

**Скрытое (декларативное) состояние**

Сама последовательность значений может существовать лишь в голове программиста, и никакой явной её поддержки со стороны вычислительной модели не существует. Например, рекурсивное вычисление факториала 5 подразумевает последовательное вычисление факториала 2, факториала 3, факториала 4 и факториала 5 -- это и есть состояние. Однако "физически", на уровне кода, такой последовательности не существует.

**Явное состояние**

Если требуется подсчитать количество вызовов функции вычисления факториала, придётся вводить состояние, которое существует внутри такой функции и в идеале скрыто от внешних функций, её вызывающих.

**Явное состояние в функции -- это состояние, которое существует на протяжении более чем одного вызова этой функции без явного присутствия в её аргументах.**

Явное состояние реализуется с помощью своего рода контейнера, который мы называем **ячейка**, и существует уже не только в сознании программиста.

**Ячейка характеризуется**
- своим именем,
- неограниченным сроком службы и
- содержанием, которое может быть изменено.

**Декларативная модель, расширенная ячейками, называется stateful-модель.**

## Как продуктивно разрабатывать системы в stateful-модели и в императивном программировании?

Какое отношение концепция состояния имеет к построению сложных программных систем?

Самый успешный и продуктивный способ построения системы для людей, способности которых к логическому мышлению существенно ограничены -- это **принцип абстракций**. Любая система состоит из двух частей: **спецификации и реализации**.
Спецификация -- это формальный контракт, который определяет, как мир взаимодействует с системой, если смотреть на это взаимодействие со стороны.
Реализация -- это то, как система сконструирована, если смотреть на это изнутри неё.

Замечательное свойство спецификации в том, что **спецификация, как правило, намного проще для понимания, нежели реализация**. Не нужно знать, как устроены часы, чтобы понимать, какое время они показывают.

Это означает, что можно эффективно строить систему в виде серии слоев абстракций. В каждом слое формируется реализация, которая использует спецификацию более низкого уровня, и предоставляет свою спецификацию слою выше. Не обязательно пытаться понимать всю систему сразу.

**Растущие системы**

Принцип абстракции не очень хорошо поддерживается декларативным и функциональным программированием, потому что мы не можем вкладывать новые знания в компоненты или функции, инкапсулируя эти знания внутри.

## Принцип абстракции

 Какой должна быть система, чтобы обеспечить наилучшую поддержку принципа абстракции?

У неё должны присутствовать три ключевые характеристики:
- **Инкапсуляция**: возможность скрывать внутренние части системы;
- **Композиционность**: возможность комбинировать части системы, чтобы получать новые части;
- **Instantiation/invocation**: возможность создания множества экземпляров на основе единого их определения. После своего создания экземпляры самоподключаются к своему окружению, в котором будут существовать.

Даже поверхностным взглядом на эти характеристики программист, знакомый с ООП, выделит знакомые концепции: инкапсуляция уже присутствует; классы можно комбинировать путём наследования или композиции; на основе класса как типа данных можно создавать экземпляры, объекты, которые сразу же доступны для работы.

Но мы применяем научный подход и используем более универсальные, формальные и фундаментальные принципы программирования. Например, замыкания обеспечивают инкапсуляцию, и программирование высших порядков обеспечивает инстанцирование (создание экземпляров).

**Важная особенность такого набора характеристик, что он не требует напрямую использования концепции состояния**.

Инкапсуляция, формально говоря, вообще ортогональна состоянию, и её вполне можно применять в декларативном программировании, а состояния могут обходиться без инкапсуляции (например, через создание глобальных переменных).

Однако простое добавление состояния к декларативному программированию резко усложняет возможность рассуждения о программе, серьёзно затрудняет её понимание. Это прежде всего **побочные эффекты**, когда функция может менять состояния, которые видимы во всей остальной программе. Поэтому **явное состояние правильно всегда применять в тесной связке с инкапсуляцией**. Тогда появляется возможность проектировать stateful-системы корректно, для чего вводится **понятие инварианта, который всегда правилен, если смотреть на него извне, "снаружи"**. Таким образом мы снова можем рассуждать о каждой подсистеме достаточно формально, считая, что её поведение не зависит от окружающей среды, что частично приближает нас к комфортному в этом плане декларативному программированию. Однако даже использование инвариантов не делает программированиие с помощью состояний таким простым, как декларативное.

**Инвариант сам по себе просто определяет, что некоторый компонент не ведет себя некорректно**, но не гарантирует, что он помогает в продвижении к итоговой цели (решению). **Хорошее правило для сложных систем -- создавать как можно больше компонентов в декларативной парадигме**. Состояние не должно быть "размазано" по многим компонентам, его надо концентрировать буквально в единичных тщательно отобранных компонентах.

## Вопросы для самопроверки:

**5. Состояние – это...**

( ) Ячейка-контейнер

(x) Последовательность значений во времени

( ) Типизированная переменная

**6. Принцип абстракций подразумевает, что система состоит из ...**

(x) спецификации и реализации

( ) интерфейса и реализации

( ) типа и имплементации

**7. Выберите одну лишнюю ключевую характеристику правильной системы**

( ) инкапсуляция

( ) композиционность

(x) полиморфизм

( ) instantiation/invocation

**8. Выберите одно неверное утверждение**

( ) инварианты обеспечивают корректность всех подсистем проекта

( ) состояние надо всегда инкапсулировать

(x) состояние может быть "размазано" по многим компонентам, если оно инкапсулировавно

( ) состояние вносит побочные эффекты

( ) как можно больше подсистем надо создавать в декларативной модели

Явное состояние - это пара из двух сущностей языка программирования. Первая сущность -- это **идентичность (identity)** состояния, способ его именования в программе, а второе - **текущее содержание состояния** (значение, с которым связано имя, идентичность состояния). И существует операция, которая позволяет через идентичность состояния получить текущее содержимое состояния.

# Ячейка

Мы добавляем новый базовый тип в вычислительную модель -- явное состояние, и называем его **ячейка**.

Ячейка состоит из неизменяемого имени и связанной с ним ссылки на объект в хранилище однократных присваиваний. Так как имя ячейки менять не допускается, **все ячейки получаются чистыми АТД**. Множество всех ячеек располагается в мутабельном хранилище.

Итоговая вычислительная модель состоит из иммутабельного хранилища однократных присваиваний, которое хранит dataflow-переменные (которые могут быть связаны только с одним значением), и из мутабельного хранилища, которое хранит пары из имён и ссылок. В этой вычислительной модели существует простой язык программирования, который расширяет декларативную модель всего двумя операциями: NewCell и Exchange.

NewCell имеет два параметра C и X и создаёт новую ячейку с именем C и содержимым X.

Exchange имеет три параметра C, X и Y, связывает X с прежним (текущим) содержимым ячейки C, и задаёт этой ячейке новое содержимое Y.

Для большей выразительности в терминах этих операций в модель добавляются ещё две инструкции.

Операция @ организует доступ к содержимому ячейки C:

`X = @C`

Операция := присваивает ячейке C новое значение Y, и возвращает старое значение ячейки X:

`C := Y`

Удивительно, но **добавления ячейки с двумя операциями (фактически, классические запись значения и считывание значения) достаточно, чтобы построить все замечательные концепции, которые может предоставить понятие состояния!**

**Все сложные концепции объектов, классов и других абстрактных типов данных могут быть построены с помощью декларативной модели, дополненной ячейками.**

Это семантика, но и языки обычно имеют синтаксическую поддержку этих концепций, чтобы они стали простыми в использовании, а реализация обеспечивает их эффективность.

# Связь с декларативным программированием

Вообще говоря, stateful-программа не может считаться декларативной, так как её прогон несколько раз с одними и теми же входами может давать разные выходы в зависимости от её внутреннего состояния. Можно, однако, писать stateful-программы так, что они будут вести себя как если они декларативные -- т.е. писать их так, чтобы они удовлетворяли определению декларативной операции. Это сам по себе хороший принцип проектирования: **писать stateful-компоненты так, чтобы они вели себя декларативно**.

Можно взять любую функцию из предыдущего курса, например Filter(), и переписать её в императивном виде, без рекурсии: просто одним циклом перебрать все элементы списка, и если очередной элемент отвечает требованиям функции-предиката, добавляем его в список-результат. Этот список-результат -- локальная переменная внутри Filter, явное состояние, однако с точки зрения пользователя функция Filter осталась декларативной: она не меняет значения аргументов и не создаёт никаких других побочных эффектов. **Мы просто сменили декларативную реализацию декларативной функции Filter на императивную, оставив её "интерфейс" (сигнатуру) неизменным**.

Ещё одна полезная вещь, связанная с состоянием и декларативной моделью -- это мемоизация, когда функция запоминает результаты предыдущих вызовов (если они например требовали больших объёмов вычислений), и при повторных вызовах с теми же параметрами выдаёт результат молниеносно. Такая функция где-то внутри работает с состояниями (замыканием), однако формально остаётся декларативной.

## Вопросы для самопроверки:

**12. Ячейка -- это ...**

( ) переменная

( ) элемент в иммутабельном хранилище

(x) имя и связанная с ним ссылка на объект

**13. Сколько операций для ячейки достаточно, чтобы полноценно реализовать концепцию состояния?**

( ) три

(x) две

( ) четыре

**14. Как писать stateful-компоненты так, чтобы они вели себя декларативно?**

(x) сохранять декларативный интерфейс

( ) сохранять декларативную реализацию

( ) сохранять декларативные интерфейс и реализацию

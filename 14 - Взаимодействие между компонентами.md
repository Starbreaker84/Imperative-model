Когда компоненты соединены вместе, они должны начать взаимодействовать друг с другом. Далее приведены шесть наиболее популярных протоколов для такого взаимодействия, в порядке возрастания независимости компонентов.

### 1. Процедура/функция.

Логика программы последовательна, и один компонент вызывает другой как функцию. Вызывающая сторона может быть не единственным инициатором такого вызова; допустимы вложенные вызовы, когда фокус управления переходит от одного компонента к другому. **Но всегда существует только один глобальный фокус управления, который в каждый момент времени напрямую связывает два конкретных компонента**.

### 2. Корутина.

Два компонента выполняются независимо, но последовательно передавая управление друг другу. Выполнилась часть кода одного компонента, затем управление передаётся другому компоненту, который выполняет часть своего кода, и передаёт управление обратно первому компоненту, который продолжает работу с последней промежуточной точки (с сохранением своих локальных состояний), и т. д.
Тут возникает уже **несколько фокусов контроля, по одному на каждую корутину**. Этот протокол более свободный, нежели предыдущий, но компоненты всё ещё зависимы, поскольку выполняются попеременно и связаны с друг с другом. 

### 3. Параллельность и синхронизм.

Третья схема - когда каждый компонент развивается независимо от других, и может инициировать и завершать связь с другим компонентом в соответствии с некоторым протоколом, который согласован для обоих компонентов. Компоненты работают параллельно. **Тут существует несколько фокусов контроля, которые называются "нити" (threads)**, мы их проходили на первом курсе по парадигмам. Каждый компонент однако обращается к другим компонентам **синхронно**: компонент, отправивший кому-то запрос, ожидает ответа, больше ничего не делая до получения ответа (или разрыва связи по ошибке - таймауту например).

### 4. Параллельность и асинхронизм.

Множество параллельно работающих компонентов, которые взаимодействуют через асинхронные каналы. Каждый компонент может посылать сообщения другим, однако не обязан пассивно ожидать ответа, и может продолжать свою работу. Асинхронные каналы могут работать по разным схемам (например, обрабатывая сообщения в порядке их поступления, или случайно), и такие каналы называются **потоки (streams)**.
В этой схеме компонент должен знать некоторый идентификатор компонента, с которым он обменивается сообщениями. 

### 5. Параллельный почтовый ящик.

Это разновидность предыдущей схемы, когда асинхронные каналы работают как "почтовые ящики", накапливая поступающие сообщения, каждое из которых адресуется конкретному компоненту. В таком случае появляется возможность выполнять сопоставление с образцом, выделяя нужное подмножество сообщений в канале, и не затрагивая другие сообщения, что очень удобно в параллельных системах. Такая схема реализована, например, в языке Erlang.

### 6. Согласованная модель.

Это схема, когда отправитель и получатель сообщений не должны знать идентификационную информацию друг друга. Такая абстракция называется **пространство кортежей (tuple space)** - парадигма ассоциативной памяти для параллельных/распределённых вычислений, применяемая к интерфейсам компонентов. Компоненты работают параллельно, и взаимодействуют исключительно через общее пространство кортежей.
Один компонент может асинхронно отправить сообщение, а другой - "получить" его в том смысле, что его надо явно найти по шаблону, как в почтовом ящике.

## Принцип независимости модели

Каждый компонент в системе может разрабатываться в какой-то своей оригинальной вычислительной модели. В процессе разработки внутренняя структура компонента может кардинально изменяться: нередко меняется вычислительная модель, stateless-компонент может стать компонентом с состоянием (или параллельным, или распределённым, и т.д.), или наоборот.

Если такое изменение происходит на уровне реализации компонента, нет необходимости изменять его интерфейс. **Интерфейс требуется менять только в том случае, если меняется функциональность компонента, видимая извне**. Это важное свойство модульности вычислительных моделей. До тех пор, пока интерфейс остается неизменным, это свойство гарантирует, что нет необходимости изменять что-либо ещё в остальной части системы.

Это базовый принцип проектирования для всех вычислительных моделей:

**Интерфейс компонента должен быть независим от вычислительной модели, используемой для реализации компонента. Интерфейс зависит исключительно от внешне видимой функциональности компонента.**

Хороший пример этого принципа - мемоизация. Функция вычисляет некоторый результат, который требует существенного объёма вычислений, и кэширует свои параметры так, что если вызов функции с конкретными значениями уже выполнялся, то сразу выдаётся уже готовый результат, вычисленный ранее. Но несмотря на то, что кэш мемоизации, очевидно, требует работы с состояниями (мы переходим от декларативной модели к stateful-модели), смена внутренней реализации компонента не требует абсолютно никаких изменений в остальном коде системы.

**Вопросы для самопроверки:**

**40. Чем протокол с корутинами отличается от протокола с функциями?**

(x) в случае корутин существует несколько фокусов контроля

( ) компоненты с корутинами выполняются независимо

( ) функции могут быть вложены, а корутины нет

**41. Чем синхронизм отличается от асинхронизма?**

( ) компоненты и там и там работают параллельно

(x) синхронный компонент должен пассивно ожидать ответа связанного компонента

( ) синхронный компонент должен знать идентификатор связанного компонента

**42. В чём разница между моделью почтового ящика и согласованной моделью?**

( ) почтовые ящики работают как синхронные каналы

(x) в согласованной модели используется ассоциативная память

( ) отправитель и получатель всегда должны знать идентификационную информацию

**43. В чём заключается базовый принцип проектирования?**

( ) интерфейс компонента должен быть согласован с вычислительной моделью его реализации

(x) интерфейс компонента независим от вычислительной модели в его реализации

( ) интерфейс компонента зависит от внешней и внутренней функциональности компонента

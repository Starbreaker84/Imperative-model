> "Хорошее программное обеспечение хорошо и in large, и in small, и в своей высокоуровневой архитектуре, и в деталях низкого уровня"

Бертран Мейер

Под **programming in large (программирование в большом)** в программной инженерии (которую саму по себе тоже нередко называют programming in large) понимается прежде всего коллективная разработка, но к этому классическому определению имеется ряд важных уточнений и нюансов.

Programming in small - это про то, как закодировать конкретную функцию или создать автономный класс с набором методов. Конечно, алгоритм, реализуемый функцией, может быть очень сложным, и методы класса могут реализовывать сложную логику, и сам код всегда должен быть выразительным, ясным и аккуратным. Но это остаётся уровень programming in small - до тех пор, пока мы не попытаемся выполнить композицию нашей функции с другой функцией, или встроить наш класс в иерархию, в семейство активно взаимодействующих объектов. И вот тут сразу начинается programming in large.

**Любое программирование - это прежде всего про проектирование (и про декомпозицию)**.

**Как нам строить системы всё большей и большей сложности, сохраняя итоговую сложность как линейную сумму сложностей отдельных подсистем?** Большая система, понятно, будет создаваться коллективом разработчиков, однако в программной инженерии объёмы работ часто измеряются в человеко-годах, то есть срок в десять человеко-лет может подразумевать, что проект будет сделан одним разработчиком за 10 лет, или 10 разработчиками за один год. Хорошо известно также, что увеличение количества программистов даёт отнюдь не линейный рост продуктивности, а гораздо меньший, и это собственно и есть ключевая тема programming in large. Фактически нету разницы, делает ли проект один человек или десять человек: **уже спустя пару месяцев собственный код обычно забывается и воспринимается как чужой**.

Но, конечно, коллективная разработка включает в себя множество специфических аспектов, связанных с общением и координацией действий сотрудников. Управлять командой, чтобы она совместно эффективно работала, сложно вообще в любой области - от инженерной до спортивной. В программировании ситуация особо усугубляется тем, что проекты весьма немилосердны даже к небольшим ошибкам. Программы требуют такой точности, которую человеку крайне трудно обеспечить.

На самом деле, внутри programming in large тоже существуют свои градации. Одно дело - разработать систему на несколько десятков тысяч строк, другое дело - на сотни тысяч строк, третье дело - на миллионы, десятки и сотни миллионов строк... На каждом уровне обычно применяются свои методологии; **мы рассмотрим базовую схему programming in large для небольших команд (до 7 человек)**.


## Методология проектирования in large

О правильной методологии проектирования programming in large написано очень много статей и книг - к сожалению как правильных, так и весьма ложных. Большая часть нынешней литературы фактически представляет собой экстраполяцию ограниченных экспериментов, поскольку строгая проверка очень трудна. Чтобы проверить некоторую идею, необходимо, чтобы несколько практически одинаковых команд работали над схожими задачами в идентичных условиях. Это редко кому удавалось сделать, и такие попытки смотрятся весьма сомнительными.

В этом разделе обобщены уроки, которые команда Van Roy сотоварищи извлекла из собственного опыта создания крупных систем - на основании своих же рекомендаций по применению парадигм программирования к разработке нескольких больших программных комплексов. Эти люди много думали в процессе работы о том, как же спроектировать хорошую программу, рефлексировали и наблюдали, как работают некоторые другие успешные команды разработчиков, и в итоге попытались выделить наиболее полезные принципы.

## Управление командой

Первая и самая важная задача заключается в том, чтобы убедиться, что **команда работает действительно слаженно - как Команда**. Не будем вдаваться в специфику командной работы, это тема совсем не моей Школы, отмечу только ключевые моменты:

- **Чёткое разграничение ответственности каждого разработчика**. Границы должностных обязанностей не должны пересекаться, что позволит избежать бесконечных дискуссий о том, кто должен был устранить конкретную проблему, и вопросов "а почему я?".

- В отличие от ответственности, **проектными знаниями следует обмениваться максимально свободно**. Разработчики должны постоянно обмениваться информацией о различных подсистемах проекта. В идеале, **в команде не должно быть ни одного незаменимого сотрудника**. Все крупные изменения в системе должны обсуждаться коллективно, однако важно, чтобы непосредственно ответственный за модуль/компонент имел последнее слово, как он должен быть реализован. Младшие сотрудники должны проходить стажировку у более старших разработчиков, чтобы быстрее и полнее изучить систему. При этом сеньоры должны выдавать конкретные задания джуниорам так, чтобы те выполняли их настолько независимо, насколько это только возможно.

- **Тщательное документирование всех интерфейсов всех компонентов**, поскольку они также становятся интерфейсами между автором компонента и другими членами команды. Документация в programming in large особенно важна, гораздо более важна, чем при программировании в малом.


## Методология разработки

Существует множество способов организации разработки программного обеспечения. Стократно в статьях и книгах обсуждались методы разработки сверху вниз, снизу вверх и даже "посередине". Увы, мировая практика показывает, что ни одна из этих методик не является хотя бы удовлетворительной на практике, а попытки их механической интеграции только делают проекту хуже. Основная проблема заключается в том, что все они полагаются на то, что требования к системе и её спецификация (техническое задание, ТЗ) должны быть изначально уже достаточно полными, т.е. разработчики предвидят большинство функциональных и нефункциональных проектных требований. Однако если только система уже не была заранее очень хорошо изучена и формализована заказчиком, этого практически невозможно достичь.

Van Roy по своему опыту предлагает методологию, которая достаточно хорошо работает в ситуации нечётких требований - так называемый подход "**от тонкого к толстому" (thin-to-thick)** - своеобразная модификация agile-подходов, дополненная хорошей научной базой.


## Thin-to-thick

**Начинаем с минимального количества проектных требований** (подмножества потенциального множества всех требований), и **создаём систему, полностью (это важно!) реализующую этот минимальный набор**.

ТЗ, спецификация и архитектура системы - пока "пустые оболочки". Они достаточно полны для того, чтобы можно было в перспективе построить работающую систему, но пока не решают почти никаких проблем пользователя, кроме самых базовых и элементарных.

Не надо путать данный шаг с созданием прототипа - **сразу создаётся именно полноценно работающая система**, отвечающая всем первичным требованиям и готовая к дальнейшему развитию и расширению.

**Постоянно и плавно расширяем и реализуем множество проектных требований, охватывая разные уровни логики и архитектуры**. Тут можно сказать, что приложение "растёт" или "развивается". Иногда такой подход называют эволюционным.

Важно, что **в любой момент времени всегда существует работающая система, которая удовлетворяет своей спецификации, и которая может быть оценена потенциальными пользователями**.

В качестве конкретной методологии разработки (ведения и реализации проектных требований) можно применять какой-нибудь "спокойный" (не экстремальный) agile-подход вроде Канбана.

В процессе разработки не выполняется никакая оптимизация - точнее, **не делается то, что явно не задано в ТЗ**. То есть не надо делать проект более сложным только для того, чтобы увеличить производительность.

Используйте простые алгоритмы с приемлемой сложностью, и поддерживайте простой проектный дизайн с правильными абстракциями. Не беспокойтесь о потенциальных накладных расходах этих абстракций.

Оптимизация может быть проведена в конце разработки, и только если возникнут реальные проблемы с производительностью. Части системы, которые потом потенциально потребуется переписать, обычно очень маленькие, и достаточно легко выявляются с помощью классических техник профилирования.

По ходу работ **периодически реорганизуйте проектный дизайн, чтобы сохранить хорошую компоновку абстракций**. Компоненты должны выразительно инкапсулировать проектные решения и реализовывать общие абстракции. Такая реорганизация иногда не совсем точно называется "рефакторинг".

Существуют две крайности: полностью планировать проектный дизайн заранее, и полностью полагаться на рефакторинг "в процессе". Лучший подход, как обычно, где-то посередине.
Мастерство такого баланса - признак сеньорской квалификации.

## Вопросы для самопроверки:

**34. Что такое Programming in large? (выберите одно неверное утверждение)**

( ) коллективная разработка ПО

(x) как правильно писать классы и функции

( ) как правильно проектировать иерархию классов и комбинировать функции

( ) программная инженерия

**35. Как правильно управлять командой разработчиков? (выберите одно второстепенное утверждение)**

( ) тщательное документирование всех интерфейсов всех компонентов

( ) чёткое разграничение ответственности каждого разработчика

(x) джуниоры должны проходить стажировку у сеньоров

( ) проектными знаниями следует обмениваться максимально свободно

**36. Выберите одно неверное утверждение по методологии thin-to-thick.**

(x) исходно начинаем с создания прототипа

( ) в процессе плавно расширяем множество проектных требований

( ) исходно начинаем с минимального количества проектных требований

( ) периодически реорганизуем проектный дизайн

( ) в процессе не выполняем никакой оптимизации

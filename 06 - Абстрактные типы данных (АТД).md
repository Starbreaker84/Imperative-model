Мы изучали абстрактный тип данных в декларативной модели - это **набор значений вместе с набором операций над этими значениями**. Теперь мы добавим в АТД понятие состояния.

# 8 способов организации АТД

АТД с одинаковой функциональностью "внутри" могут быть организованы (реализованы) по-разному. Например, ранее мы изучали, как сделать АТД защищённым. Теперь введём ещё две оси - **состояние и бандлинг** (bundling; упаковка, связывание, комплектация), каждая из которых предлагает два варианта. Эти три оси ортогональны, и в общей сложности получается восемь способов для организации АТД. Одни из них используются редко, другие распространены, но у каждого свои преимущества и недостатки.

## 1 - Открытость и защищённость

**Открытый АТД - это такой АТД, внутреннее представление которого полностью видимо во всей программе**. Реализация может быть распределена по всему коду, и различные её части могут расширять реализацию независимо друг от друга. Это полезно для небольших проектов, когда выразительность значительно важнее, нежели безопасность.

**Защищенный (безопасный) АТД - это такой АТД, реализация которого сосредоточена в одной части программы, и недоступна остальным частям**. Обычно так желательно или требуется в больших проектах, потому что такой подход позволяет реализовать и тестировать АТД независимо. Возможно, вы удивитесь, но безопасный ADT может быть полностью определён в декларативной модели, используя принципы программирования высшего порядка. Никаких дополнительных концепций (например, имён и видимости) не требуется.

АТД может быть **частично безопасным** - например, права на просмотр его внутренней реализации могут быть выданы контролируемым образом, как мы реализовывали функции Wrap и Unwrap для реализации стеков.

## 2 - Состояние

Stateless-АТД (или декларативный АТД) создаётся в декларативной модели. **Декларативные экземпляры АТД модифицировать не разрешается: надо создавать новые сущности**. Поэтому, когда процедуре передаётся экземпляр АТД, всегда можно быть уверенным, что это значение уникальное - после своего создания экземпляр АТД никогда не изменяется. С другой стороны, такой подход приводит к увеличению количества экземпляров в программе, которыми со временем становится трудно управлять. Код также получается менее модульным, поскольку экземпляры должны явно передаваться по конвейеру даже через те части, которые могут и не нуждаться в экземпляре АТД.

**Stateful-АТД внутри использует явное состояние. При таком подходе экземпляры АТД могут изменяться с течением времени**. При этом нельзя быть уверенным, какое именно значение инкапсулировано внутри экземпляра, не зная истории всех вызовов процедур с момента его создания.

В отличие от декларативных АТД, в данном случае существует только один физический экземпляр. Более того, этот единственный экземпляр часто даже не нужно передавать в функции в качестве параметра; доступ к нему можно получить с помощью лексического замыкания. Такой подход делает программу более лаконичной. Программа также становится потенциально более модульной, поскольку части, которым не нужен экземпляр, можно не упоминать.


## 3 - Бандлинг

Наряду с безопасностью и состоянием, третий выбор, который необходимо сделать, заключается в том, будут ли данные храниться отдельно от операций (распаковка, unbundled), или же будут храниться вместе (bundled). Конечно, распакованный АТД всегда можно запаковать тривиальным способом, поместив данные и операции в одно целое. Но запакованный АТД практически не может быть распакован; семантика гарантирует, что он всегда остается запакованным. Конечно, всегда можно выполнить технический рефакторинг проекта, тут речь о формальном подходе к распаковке.

**Распакованный АТД - это АТД, для которого можно отделить данные от операций**. Замечательный факт, что **распакованный АТД может быть безопасным**. Для этого каждый экземпляр создается вместе с "ключом". Ключ - это разрешение на доступ к внутренним данным экземпляра (и обновление их, если экземпляр имеет состояние). Все операции АТД знают ключ, но остальная часть программы не имеет к ключу доступа. Обычно ключ - это имя (неизменяемая константа).

Распакованный АТД может быть более эффективным, чем запакованный. Например, в файле можно хранить наборы значений, каждое из которых будет соответствовать своему экземпляру АТД. Запакованный АТД подразумевает, что требуется хранить вместе и код и операции таким образом, что они не могут быть разделены программистом. Пример - ООП, когда в памяти каждый объект хранится как набор данных и операций их обработки (методов). На практике, конечно, один и тот же код методов целиком в каждом объекте физически обычно не хранится, достаточно иметь лишь ссылку на код, и тем не менее сам подход создаёт ощутимые сложности.

## Вопросы для самопроверки:

**18. Защищённый АТД - это АТД ...**

(x) реализация которого сосредоточена в одной части программы и недоступна остальным частям

( ) в котором все поля инкапсулированы

( ) реализация которого сосредоточена в одной части программы, но доступна остальным частям

**19. Stateful-АТД - это АТД ...**

( ) в котором все поля доступны для модификации

( ) в котором имеются собственные инкапсулированные поля

(x) экземпляр которого может изменяться с течением времен

**20. Распакованный АТД - это АТД ...**

( ) значения которого можно хранить в файле

( ) в котором все поля публичны

(x) для которого можно отделить данные от операций

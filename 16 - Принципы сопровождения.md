### Минимизируйте количество внешних зависимостей.

Компонент, который зависит от другого компонента (требует его для своей работы) - потенциальный источник проблем. Если изменить другой компонент, то придётся изменить и данный компонент. Это основной источник "гниения программного обеспечения", когда некогда работавшая система перестает работать из-за стремительного роста затрат ресурсов на модификацию и исправление ошибок.
Как с этим бороться продуктивно и технично, я рассказываю на курсе Ясное Легаси :)

### Минимизируйте количество возможных уровней косвенной связи.

Это дополнение предыдущего принципа: когда компонент A связан с компонентом B, и обновление B требует обновления A. Любая косвенная связь - это своего рода классический "указатель", источник огромного количества ошибок в языках наподобие Си и С++. Задача тут - избежать ошибочного ("висячего") указателя, который "указывает" на то, что больше не имеет смысла для источника. Изменение B может привести к тому, что указатель A станет "висячим". Но B не знает о том, что на него есть указатель в A, и поэтому не может предотвратить такую ситуацию.

Предупредить подобное можно, не изменяя компонент B, а только создавая его модифицированные копии. Это может хорошо работать, если в исполнительной (runtime) системе есть автоматическая поддержка управления памятью. Классический пример данной проблемы - URL-ы в интернете, которые часто устаревают и пропадают, а в самой Сети нету никаких соответствующих формальных протоколов, средств поддержки "качества обслуживания". 

### Зависимости в системе должны быть предсказуемыми.

Ещё один наглядный пример сложного и непредсказуемого поведения - это пресловутое "кэширование страниц" веб-браузерами. Кэширование страниц - это неправильное название, потому что настоящий кэш поддерживает когерентность между оригиналом и копией. Поведение всех подсистем в проекте, на которые завязаны другие подсистемы, должно быть чётко регламентировано.

### Принимайте решения на правильном уровне абстракций.

Например, таймаут (отказ в обслуживании, в ответе на запрос, из-за долгого ожидания) - это необратимое проектное решение, принимаемое на низком уровне системы (глубоко вложенный компонент), которое однако распространяется вплоть до самого верхнего уровня без какой-либо возможности для промежуточных компонентов вмешаться в этот процесс. Такое поведение может свести на нет всю работу, которую проделал проектировщик. 

### Детально документируйте всё.

Каждый раз, когда нарушается один из предыдущих принципов (возможно, по уважительной причине - например, возникли физические ограничения наподобие нехватки памяти, или разделение по физическим серверам создало "висячий" указатель), это должно быть задокументировано! То есть все внешние зависимости, все уровни косвенных связей, все слабо предсказуемые зависимости и все "необратимые" решения наподобие таймаута должны документироваться, в идеале, в вики-подобной системе с тегированием.

### Простая физическая иерархия вложенности.

Система не должна храниться физически разрозненно в файловой системе, она должна быть собрана в одном месте, насколько это только возможно. 

Главное правило: **проектный дизайн должен быть максимально простым для сопровождения**.

Например, если ваш проект хранится в виде физических файлов (очевидно, частый случай), то:

1. Если возможно (например, проект небольшой), **поместите весь код в один файл**, внутри которого возможна своя структуризация по компонентам. Такую структуризацию обычно поддерживают редакторы кода в IDE с помощью специальных инструкций.

2. Если пункт 1 невозможен (например, файлы хранят код на разных языках, или над разными частями системы одновременно работают разные люди), **все файлы располагаем в одном каталоге** (без вложенных подкаталогов).

3. Если предыдущие пункты невозможны (например, проект по-разному собирается под разные платформы), **помещаем файлы проекта в иерархию каталогов с единым корневым каталогом**.

Кроме того, на курсе по ООАП рассматривается схема структуризации через синтаксические единицы и виртуальные каталоги.

### Вопросы для самопроверки:

**47. Выберите ошибочный принцип сопровождения:**

( ) минимизируйте количество уровней косвенной связи

( ) минимизируйте количество внешних зависимостей

(x) избегайте висячих указателей в коде

**48. Выберите ошибочный принцип сопровождения:**

( ) зависимости в системе должны быть предсказуемыми

(x) обрабатывайте отказы в обслуживании в точке их возникновения

( ) принимайте решения на правильном уровне абстракций

**49. Выберите ошибочный принцип сопровождения:**

( ) поддерживайте простую физическую иерархию вложенности

(x) помещайте файлы проекта в иерархию каталогов

( ) детально документируйте всё

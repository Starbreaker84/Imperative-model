**Плюсы методики "от тонкого к толстому":**

- баги всех видов выявляются быстро и рано и легко устраняются;

- давление дедлайна значительно сокращается, так как всегда имеется действующее рабочее приложение;

- разработчики более мотивированы, поскольку получают быструю обратную связь по своим усилиям;

- пользователи с большей вероятностью получают то, что им действительно нужно, потому что у них есть возможность использовать продукт непосредственно в процессе его разработки;

- архитектура с большей вероятностью получится хорошей, так как её можно исправлять на ранних стадиях работ;

- пользовательский интерфейс с большей вероятностью будет хорошим, поскольку он постоянно улучшается в процессе разработки через обратную связь от пользователей работающей версии.

## Programming in large на практике

Но как же надо структурировать будущую большую систему, требования к которой пока слабо понятны? Какую абстракцию тут лучше выбрать, чтобы она хорошо поддерживала и продуктивную командную работу, и методику "от тонкого к толстому"? Один из способов, который проверенно работает на практике - это **структурировать проект как иерархический граф с чётко определенными интерфейсами на каждом уровне**.

![](https://skillsmart.ru/data//stt/state1.png)

Проектируемая система состоит из набора узлов (подсистем), где каждый узел связан/взаимодействует с некоторыми другими узлами. Каждый узел - это экземпляр компонента, но и на уровне системы типов проект организован таким же образом - в виде иерархии компонентов (например, классов). Интерфейсы здесь - например, формальнрые наборы операций АТД.

Принципиальный момент, что, как вы, вероятно, догадались, каждый узел в свою очередь декомпозируется в граф со своей внутренней структурой. Декомпозиция заканчивается, когда мы достигаем примитивных компонентов, предоставляемых базовым логическим уровнем.

В реальных проектах уровней декомпозиции немного, часто вполне достаточно двух-трёх уровней "вложенности". Декомпозицию в данном случае не надо путать с методикой проектирования "сверху вниз" (в чём различие, поясняется далее). Практическую методику - реализацию этого подхода с помощью ООП - вы изучали на двух курсах по ООАП, когда создавали множество почти равноправных АТД.

## 1) Связи между компонентами

Первый шаг в проектировании системы по имеющемуся множеству проектных требований - это **выбор схемы соединения компонентов**. Тут возможны два варианта.

**1. Статическая структура**.

Граф компонентов хорошо понятен с самого начала разработки системы. В таком случае компоненты могут быть связаны друг с другом сразу же, когда приложение запускается.

Каждый экземпляр компонента примерно соответствует набору функциональных возможностей, который называют **библиотека или модуль**.

Важный момент: очень желательно, чтобы **каждый экземпляр компонента существовал в системе не более чем в одном виде** (паттерн Синглетон), поэтому не следует смешивать компонент и классический класс, подразумевающий порождение множества экземпляров. Тут речь идёт именно о библиотеках или модулях/пакетах. Как вариант, под компонентом можно понимать статический класс. Если библиотека требуется в нескольких разных подсистемах проекта, мы хотим, чтобы все они использовали одну и ту же физическую библиотеку (инстанс).

Статическая структура на практике может реализовываться компонентами как синтаксическими единицами компиляции, хранящимися в отдельных файлах. Такие компоненты называют **функторы**, которые могут компилироваться независимо от других функторов. **Зависимости между функторами задаются через физические имена файлов**. Чтобы быть доступным для других функторов, функтор должен быть "записан" в файл, что позволяет однозначно обращаться к нему по имени файла с помощью типовых инструкций любого языка программирования для подключения модулей.

Функтор представляется двумя форматами: файл с исходным текстом, и файл со скомпилированным кодом (например, байт-кодом виртуальной машины или нативным машинным кодом).

**Приложение - обычно один конкретный скомпилированный функтор**. Для его запуска все остальные скомпилированные функторы, явно или косвенно связанные с главным, должны быть собраны вместе и "построены" в единое целое. При запуске главного функтора все связанные функторы автоматически линкуются с ним, и создаются их экземпляры. Такая связь может быть статической (на этапе компиляции) или динамической (функторы подгружаются во время работы программы).


**2. Динамическая структура**

Часто приложение выполняет вычисления с компонентами, которые возникают и связываются друг с другом непосредственно во время выполнения. Или программа может создать новый компонент и сохранить его, и т. д. Экземпляры компонентов в данном варианте не обязательно должны быть общими (глобальными) синглетонами; возможно, потребуется несколько экземпляров одного компонента (модуля или типа данных). Например, компонент может реализовать интерфейс к базе данных (что часто требуется в задачах репликации). В зависимости от того, используется ли одна или несколько внешних баз данных, необходимо будет создать один или несколько экземпляров компонента. Это определяется во время выполнения, когда добавляется новая база данных (узел репликации) в горячем режиме.

Функтор в данном случае - просто ещё одна языковая сущность. Это может быть, например, класс или процедура, возможно, с более строгим описанием их интерфейса.

**Вопросы для самопроверки:**

**37. Как лучше структурировать будущую систему, требования к которой пока слабо понятны? (выберите верное утверждение)**

( ) в виде вложенных уровней абстракции с чётко определенными интерфейсами

( ) в виде иерархического дерева с чётко определенными интерфейсами

(x) в виде иерархического графа с чётко определенными интерфейсами

( ) в виде иерархии классов с чётко определенными интерфейсами

**38. Какой вариант схемы соединения компонентов неверен?**

(x) иерархическая структура

( ) динамическая структура

( ) статическая структура

**39. В какой схеме соединения компонентов очень желательно использовать синглетоны?**

(x) статическая структура

( ) динамическая структура

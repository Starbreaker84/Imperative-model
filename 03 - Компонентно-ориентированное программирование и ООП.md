# Компонентно-ориентированное программирование

Три вышеприведённые характеристики определяют так называемое **компонентно-ориентированное программирование**. Компонент специфицирует программный элемент и изнутри, и снаружи, то есть с чётко определенным интерфейсом. Внутренняя часть скрыта от внешнего наблюдения, за исключением того, что позволяет интерфейс. Компоненты могут комбинироваться для получения новых компонентов. Компоненты могут "инстанциироваться" -- создавать новые экземпляры с одинаковой структурой, которые сразу же включаются в рабочую среду.

Компоненты -- это вездесущая концепция. Программисты наверняка их постоянно встречают:

- **процедурная абстракция**: компонент -- это определение некоторой функции с формальными параметрами, а его "экземпляр" -- это вызов данной функции с конкретными аргументами;

- **функтор (модуль компиляции)**: программный модуль, который компилируется в объектный код независимо от других компонентов. В таком случае функтор -- это исходный код модуля, который компилируется в модуль;

- **параллельные компоненты**: система с независимыми и взаимодействующими сущностями может быть представлена как граф одновременно действующих компонентов, обменивающихся сообщениями.

Естественный путь расширения возможностей компонента - это **композиция**. Создаём новый компонент, который содержит уже существующий. Новый компонент предлагает новую функциональность, а для её реализации в существенной степени применяется существующий компонент.

Множество современных систем самых разных архитектур выполнено в данной компонентной модели.

# Объектно-ориентированное программирование

Разработчики, знакомые с ООП, наверняка уже распознали в компонетно-ориентированном программировании ряд знакомых черт ООП, которое добавляет к компонентному подходу четвёртую характеристику.

Это **наследование**, которое важно даже не столько как техническая возможность расширения типов, сколько как возможность развивать систему очень плавно, постепенно, небольшими шагами, через небольшие расширения или модификации другой системы.

**Постепенно развиваемые компоненты называются классы, и их экземпляры называются объекты.**

**Наследование -- это способ структурирования программ, при котором новая реализация основывается на уже существующей**. Большой плюс наследования, что оно существенно снижает избыточность и дублирование кода за счёт повторного использования, и представляет собой весьма мощный и гибкий инструмент. Но это и большой минус: компоненты начинают сильно зависеть от компонентов, которые они наследуют, и в результате подобными зависимостями становится сложно управлять.

Подавляющая часть литературы по объектно-ориентированному проектированию, например, по шаблонам проектирования, фокусируется на обучении правильному использованию наследования. Хотя композиция -- подход менее гибкий, чем наследование, он гораздо проще в использовании, и рекомендуется использовать композицию везде, где это возможно, а наследование применять только тогда, когда композиции недостаточно, а наследование подходит к задаче естественно, а иерархии получаются неглубокие (2-3 уровня).

*Я сторонник достаточно активного грамотного использования наследования (умеренной глубины), потому что с его помощью удаётся создавать очень аккуратные модульные системы с очень невысокой связностью между модулями. Как это делать, отдельно разбирается на курсах по ООАП.*

## Вопросы для самопроверки:

**9. Компонент задаётся...**

( ) внешним интерфейсом

(x) спецификацией и "изнутри", и "снаружи"

( ) внутренней реализацией

**10. Естественный путь расширения возможностей компонента -- это ...**

(x) композиция

( ) наследование

( ) полиморфизм

инкапсуляция

**11. ООП -- это компонентный подход, расширенный ...**

( ) инкапсуляцией

( ) полиморфизмом

(x) наследованием

( ) композицией

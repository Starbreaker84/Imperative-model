На практике из восьми комбинаций способа организации АТД обычно используются следующие (по мере усложнения):

- Открытый, декларативный, распакованный. Этот подход реализован например в языках Scheme и Prolog.
- Защищённый, декларативный, распакованный. Добавляем "обёртки" для реализации безопасного декларативного стиля.
- Защищённый, декларативный, запакованный. Получаем объектно-ориентированное расширение декларативного стиля.
- Защищённый, stateful, запакованный. Классический ООП, как в Smalltalk или Java.
- Защищённый, stateful, распакованный. Распакованный вариант ООП.

Первые два пункта мы рассматривали на предыдущем курсе:
- `NewStack()` – создать новый стек;
- `Push(Stack s, T elem)` – втолкнуть элемент elem в стек s;
- `Pop(Stack s)` – вытолкнуть элемент из стека s;
- `T Peek(Stack s)` – получить верхний элемент стека s, не меняя сам стек;
- `IsEmpty(Stack s)` – булева проверка, пустой ли стек s.

Первые три функции возвращают в качестве своего значения новый стек, так как все функции чистые и не меняют значений своих аргументов. 

## Защищённая декларативная распакованная версия с обёртками

- `NewStack()` возвращает `Wrap( [ ] )`.

- `Peek(Stack s)` и `IsEmpty(Stack s)` делают предварительно внутри Unwrap(s).

- `Push(Stack s, T elem)` и `Pop(Stack s)` после `Unwrap(s)` модифицируют результат и затем выполняют `Wrap()` для нового списка, который и возвращает.


## Защищённая декларативная запакованная версия

Идея -- спрятать стек внутри операций с помощью лексического замыкания, так что он не может быть от них отделён. Синтаксис становится похожим на ООП:

```
S1 = NewStack()
S1.IsEmpty()
S2 = S1.Push(23)
S3 = S2.Pop(X)
S4 = S3.Pop(Y).Push(256).Push(-1)
```

Мы придерживаемся декларативной модели, каждый "метод" по-прежнему возвращает новый стек, не меняя текущий. Так как эта версия запакована, обёртки Wrap/Unwrap вызывать не нужно: мы получаем в качестве результата не "физический" стек, а некий "объект", заглянуть внутрь которого невозможно. Для обеспечения безопасности такого АТД не требуется явного состояния, достаточно только программирование высшего порядка.

Поскольку эта версия является одновременно запакованной и безопасной, мы можем рассматривать ее как **декларативную форму объектно-ориентированного программирования**. По сути, мы получили декларативный объект.

## Защищённые stateful-версии

**Защищённый, stateful, запакованный стек** реализуется классическим подходом ООП + АТД. Есть объект, содержащий внутреннее поле (сам стек в некотором внутреннем представлении, например связный список), которое инкапсулировано, и есть методы доступа к нему и его модификации.

**Защищённый, stateful, распакованный стек** на практике применяется редко в ООП и ФП, хотя и незаслуженно. Он не требует программирования высшего порядка. **Каждая операция требует один параметр (стек) и не создаёт новый объект, модифицируя аргумент**. Только операция NewStack требует вызова Wrap, все остальные операции используют лишь Unwrap для доступа к внутреннему представлению стека.

```
S1 = NewStack()
IsEmpty(S1)
Push(S1, 23)
X = Pop(S1)
```

## Вопросы для самопроверки:

**21. ООП - это ...**

(x) защищённый, stateful, запакованный АТД

( ) защищённый, декларативный, запакованный АТД

( ) защищённый, stateful, распакованный АТД

**22. Объектно-ориентированное расширение декларативного стиля -- это ...**

( ) защищённый, stateful, запакованный АТД

(x) защищённый, декларативный, запакованный АТД

( ) защищённый, stateful, распакованный АТД

**23. Какой защищённый stateful АТД не требует создания нового объекта?**

( ) запакованный

(x) распакованный

( ) никакой
